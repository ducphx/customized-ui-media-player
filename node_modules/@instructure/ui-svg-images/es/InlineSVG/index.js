import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
const _excluded = ["style", "title", "description", "focusable", "children", "src", "styles"];

var _dec, _dec2, _dec3, _class, _class2;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/** @jsx jsx */
import { Component } from 'react';
import { omitProps, withDeterministicId } from '@instructure/ui-react-utils';
import { testable } from '@instructure/ui-testable';
import { withStyle, jsx } from '@instructure/emotion';
import generateStyle from './styles';
import generateComponentTheme from './theme';
import { allowedProps, propTypes } from './props';

/**
---
category: components/utilities
---
@tsProps
**/
let InlineSVG = (_dec = withDeterministicId(), _dec2 = withStyle(generateStyle, generateComponentTheme), _dec3 = testable(), _dec(_class = _dec2(_class = _dec3(_class = (_class2 = class InlineSVG extends Component {
  constructor(props) {
    super(props);
    this.titleId = void 0;
    this.descId = void 0;
    this.ref = null;

    this.handleRef = el => {
      const elementRef = this.props.elementRef;
      this.ref = el;

      if (typeof elementRef === 'function') {
        elementRef(el);
      }
    };

    this.titleId = props.deterministicId('InlineSVG-title');
    this.descId = props.deterministicId('InlineSVG-desc');
  }

  componentDidMount() {
    var _this$props$makeStyle, _this$props;

    (_this$props$makeStyle = (_this$props = this.props).makeStyles) === null || _this$props$makeStyle === void 0 ? void 0 : _this$props$makeStyle.call(_this$props);
  }

  componentDidUpdate() {
    var _this$props$makeStyle2, _this$props2;

    (_this$props$makeStyle2 = (_this$props2 = this.props).makeStyles) === null || _this$props$makeStyle2 === void 0 ? void 0 : _this$props$makeStyle2.call(_this$props2);
  }

  get role() {
    if (this.props.title) {
      return 'img';
    } else {
      return 'presentation';
    }
  }

  renderTitle() {
    const title = this.props.title;
    return title ? jsx("title", {
      id: this.titleId
    }, title) : null;
  }

  renderDesc(desc) {
    return desc ? jsx("desc", {
      id: this.descId
    }, desc) : null;
  }

  get labelledBy() {
    const ids = [];

    if (this.props.title) {
      ids.push(this.titleId);
    }

    if (this.props.description) {
      ids.push(this.descId);
    }

    return ids.length > 0 ? ids.join(' ') : void 0;
  }

  renderContent() {
    if (this.props.src) {
      const src = InlineSVG.prepareSrc(this.props.src);
      return jsx("g", {
        role: "presentation" // eslint-disable-next-line react/no-danger
        ,
        dangerouslySetInnerHTML: {
          __html: src
        }
      });
    } else {
      return jsx("g", {
        role: "presentation"
      }, this.props.children);
    }
  }

  render() {
    const _this$props3 = this.props,
          style = _this$props3.style,
          title = _this$props3.title,
          description = _this$props3.description,
          focusable = _this$props3.focusable,
          children = _this$props3.children,
          src = _this$props3.src,
          styles = _this$props3.styles,
          props = _objectWithoutProperties(_this$props3, _excluded); // if width or height are 'auto', don't supply anything to the SVG


    const width = this.props.width === 'auto' ? void 0 : this.props.width;
    const height = this.props.height === 'auto' ? void 0 : this.props.height;
    return jsx("svg", Object.assign({}, parseAttributes(src), omitProps(this.props, InlineSVG.allowedProps, ['inline']), {
      style: { ...style,
        width,
        height
      },
      width: width,
      height: height,
      "aria-hidden": title ? void 0 : 'true',
      "aria-labelledby": this.labelledBy,
      role: this.role,
      focusable: focusable ? 'true' : 'false',
      css: styles === null || styles === void 0 ? void 0 : styles.inlineSVG,
      className: props.className,
      ref: this.handleRef
    }), this.renderTitle(), this.renderDesc(description), this.renderContent());
  }

}, _class2.displayName = "InlineSVG", _class2.componentId = 'InlineSVG', _class2.allowedProps = allowedProps, _class2.propTypes = propTypes, _class2.defaultProps = {
  focusable: false,
  src: '',
  title: '',
  description: '',
  inline: true,
  width: '1em',
  height: '1em',
  color: 'inherit'
}, _class2.prepareSrc = src => {
  const pattern = /<svg[^>]*>((.|[\n\r])*)<\/svg>/;
  const matches = pattern.exec(src);
  return matches ? matches[1] : src;
}, _class2)) || _class) || _class) || _class);

function parseAttributes(src) {
  const attributes = {};
  const SVGAttributesRegExp = /<svg\s+([^>]*)\s*>/;
  const namesAndValuesRegExp = /(\S+)=["']?((?:.(?!["']?\s+(?:\S+)=|[>"']))+.)["']?/g;

  if (typeof src === 'string') {
    const attributesMatches = SVGAttributesRegExp.exec(src);
    const attributesString = attributesMatches ? attributesMatches[1] : '';
    const excludes = ['xmlns', 'xmlns:xlink', 'version'];
    let match = namesAndValuesRegExp.exec(attributesString);

    while (match != null) {
      if (excludes.indexOf(match[1]) === -1) {
        attributes[match[1]] = match[2] || (match[3] ? match[3] : match[4] ? match[4] : match[5]) || match[1]; // eslint-disable-line no-nested-ternary, max-len
      }

      match = namesAndValuesRegExp.exec(attributesString);
    }
  }

  return attributes;
}

export default InlineSVG;
export { InlineSVG };