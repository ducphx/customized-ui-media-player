import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
const _excluded = ["children", "textAlign", "background", "display", "withVisualDebug", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "overflowX", "overflowY", "stacking", "shadow", "position", "focusPosition", "focusColor", "shouldAnimateFocus", "borderColor", "className", "styles", "makeStyles"];

var _dec, _dec2, _class, _class2;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/** @jsx jsx */
import { Component } from 'react';
import { getComputedStyle } from '@instructure/ui-dom-utils';
import { textDirectionContextConsumer } from '@instructure/ui-i18n';
import { logError as error } from '@instructure/console';
import { getElementType, omitProps, pickProps, passthroughProps } from '@instructure/ui-react-utils';
import { jsx, withStyle } from '@instructure/emotion';
import generateStyle from './styles';
import generateComponentTheme from './theme';
import { propTypes, allowedProps } from './props';

/**
---
category: components
---
@module View
@tsProps
**/
let View = (_dec = textDirectionContextConsumer(), _dec2 = withStyle(generateStyle, generateComponentTheme), _dec(_class = _dec2(_class = (_class2 = class View extends Component {
  // TODO: Remove this code once all components are using passthroughProps in place
  // of omitProps and have removed this function
  // omitViewProps needs to be called on the composed View component so that the
  // View.allowedProps in the method matches the View.allowedProps that will be called in
  // the consumers. Otherwise the discrepancy could cause unexpected props being
  // allowed through.
  // Removes View's own props from the given object. Automatically excludes the
  // following props: 'theme', 'children', 'className', 'style', 'styles',
  // 'makeStyles', 'themeOverride'
  // @param props the object to process
  // @param Component The component whose props are processed.
  // Only needed for debug logging in non-production builds.
  get _element() {
    return this.ref;
  }

  constructor(props) {
    super(props);
    this.spanMarginVerified = void 0;
    this.ref = null;

    this.handleElementRef = el => {
      if (typeof this.props.elementRef === 'function') {
        this.props.elementRef(el);
      }

      this.ref = el;
    };

    this.spanMarginVerified = false;
  }

  componentDidMount() {
    var _this$props$makeStyle, _this$props;

    (_this$props$makeStyle = (_this$props = this.props).makeStyles) === null || _this$props$makeStyle === void 0 ? void 0 : _this$props$makeStyle.call(_this$props);
  }

  componentDidUpdate() {
    var _this$props$makeStyle2, _this$props2;

    (_this$props$makeStyle2 = (_this$props2 = this.props).makeStyles) === null || _this$props$makeStyle2 === void 0 ? void 0 : _this$props$makeStyle2.call(_this$props2); // Not calling getComputedStyle can save hundreds of ms in tests and production

    if (process.env.NODE_ENV === 'development' && !this.spanMarginVerified) {
      // We have to verify margins in the first 'componentDidUpdate',
      // because that is when all styles are calculated,
      // but we only want to check once, using a flag
      this.spanMarginVerified = true;
      error(!function verifySpanMargin(element, margin) {
        if (!element) {
          return;
        }

        const display = getComputedStyle(element).display;

        if (display !== 'inline') {
          return;
        }

        const marginValues = margin ? margin.split(' ') : null;
        let verticalMargin = false; // either top or bottom margin are set

        if (margin) {
          if (marginValues && marginValues[0] && marginValues[0] !== 'none' && marginValues[0] !== '0') {
            verticalMargin = true;
          }

          if (marginValues && marginValues[2] && marginValues[2] !== 'none' && marginValues[2] !== '0') {
            verticalMargin = true;
          }
        }

        return verticalMargin;
      }(this.ref, this.props.margin), `[View] display style is set to 'inline' and will allow for horizontal margins only.`);
    }
  }

  render() {
    const _this$props3 = this.props,
          children = _this$props3.children,
          textAlign = _this$props3.textAlign,
          background = _this$props3.background,
          display = _this$props3.display,
          withVisualDebug = _this$props3.withVisualDebug,
          width = _this$props3.width,
          height = _this$props3.height,
          minWidth = _this$props3.minWidth,
          minHeight = _this$props3.minHeight,
          maxWidth = _this$props3.maxWidth,
          maxHeight = _this$props3.maxHeight,
          overflowX = _this$props3.overflowX,
          overflowY = _this$props3.overflowY,
          stacking = _this$props3.stacking,
          shadow = _this$props3.shadow,
          position = _this$props3.position,
          focusPosition = _this$props3.focusPosition,
          focusColor = _this$props3.focusColor,
          shouldAnimateFocus = _this$props3.shouldAnimateFocus,
          borderColor = _this$props3.borderColor,
          className = _this$props3.className,
          styles = _this$props3.styles,
          makeStyles = _this$props3.makeStyles,
          props = _objectWithoutProperties(_this$props3, _excluded);

    const ElementType = getElementType(View, this.props);
    return jsx(ElementType //@ts-expect-error TODO: `ref` prop causes: "Expression produces a union type that is too complex to represent.ts(2590)"
    , Object.assign({}, passthroughProps(props), {
      className: className,
      css: [styles === null || styles === void 0 ? void 0 : styles.view, styles === null || styles === void 0 ? void 0 : styles.inlineStyles],
      ref: this.handleElementRef
    }), children);
  }

}, _class2.displayName = "View", _class2.componentId = 'View', _class2.allowedProps = allowedProps, _class2.propTypes = propTypes, _class2.defaultProps = {
  display: 'auto',
  overflowX: 'visible',
  overflowY: 'visible',
  withVisualDebug: false,
  borderColor: 'primary',
  position: 'static',
  focusPosition: 'offset',
  focusColor: 'info',
  shouldAnimateFocus: true
}, _class2.omitViewProps = (props, Component) => {
  // We don't want the theming and styling props to pass
  // (these are added and handled by the `@withStyle` decorator)
  const propsToOmit = [..._class2.allowedProps, 'styles', 'makeStyles', 'themeOverride'];

  if (process.env.NODE_ENV !== 'production') {
    Object.keys(pickProps(props, propsToOmit)).forEach(prop => {
      error(false, `[${Component.name}] prop '${prop}' is not allowed.`);
    });
  }

  return omitProps(props, propsToOmit);
}, _class2)) || _class) || _class);
export default View;
export { View };