var _dec, _dec2, _dec3, _class, _class2;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import React, { Component } from 'react';
import keycode from 'keycode';
import { Position, parsePlacement, mirrorHorizontalPlacement } from '@instructure/ui-position';
import { ContextView, View } from '@instructure/ui-view';
import { Dialog } from '@instructure/ui-dialog';
import { textDirectionContextConsumer } from '@instructure/ui-i18n';
import { findDOMNode, containsActiveElement, requestAnimationFrame, handleMouseOverOut } from '@instructure/ui-dom-utils';
import { safeCloneElement, callRenderProp, withDeterministicId } from '@instructure/ui-react-utils';
import { createChainedFunction, shallowEqual, px } from '@instructure/ui-utils';
import { logError as error } from '@instructure/console';
import { testable } from '@instructure/ui-testable';
import { FocusRegion } from '@instructure/ui-a11y-utils';
import { allowedProps, propTypes } from './props';
/**
---
category: components
tags: overlay, portal, dialog
---
@tsProps
**/

let Popover = (_dec = withDeterministicId(), _dec2 = textDirectionContextConsumer(), _dec3 = testable(), _dec(_class = _dec2(_class = _dec3(_class = (_class2 = class Popover extends Component {
  constructor(props) {
    var _this;

    super(props);
    _this = this;
    this._handleMouseOver = void 0;
    this._handleMouseOut = void 0;
    this._id = void 0;
    this._raf = [];
    this._trigger = null;
    this._view = null;
    this._dialog = null;
    this._contentElement = null;
    this._focusRegion = void 0;
    this.mouseOutTimeout = void 0;
    this.ref = null;

    this.handleRef = el => {
      const elementRef = this.props.elementRef;
      this.ref = el;

      if (typeof elementRef === 'function') {
        elementRef(el);
      }
    };

    this.show = event => {
      var _this$props$onShowCon, _this$props;

      if (typeof this.props.isShowingContent === 'undefined') {
        this.setState({
          isShowingContent: true
        });
      }

      (_this$props$onShowCon = (_this$props = this.props).onShowContent) === null || _this$props$onShowCon === void 0 ? void 0 : _this$props$onShowCon.call(_this$props, event);
    };

    this.hide = function (event) {
      let documentClick = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const _this$props2 = _this.props,
            onHideContent = _this$props2.onHideContent,
            isShowingContent = _this$props2.isShowingContent;

      if (typeof isShowingContent === 'undefined') {
        // uncontrolled, set state, fire callbacks
        _this.setState(_ref => {
          let isShowingContent = _ref.isShowingContent;

          if (isShowingContent) {
            onHideContent === null || onHideContent === void 0 ? void 0 : onHideContent(event, {
              documentClick
            });
          }

          return {
            isShowingContent: false
          };
        });
      } else if (isShowingContent) {
        // controlled, fire callback
        onHideContent === null || onHideContent === void 0 ? void 0 : onHideContent(event, {
          documentClick
        });
      }
    };

    this.toggle = event => {
      if (this.shown) {
        this.hide(event);
      } else {
        this.show(event);
      }
    };

    this.handleDialogDismiss = (event, documentClick) => {
      if (!this.props.shouldReturnFocus && this.props.shouldFocusContentOnTriggerBlur) {
        const trigger = findDOMNode(this._trigger);

        if (trigger && typeof trigger.focus === 'function') {
          ;
          trigger.focus();
        }
      }

      this.hide(event, documentClick);
    };

    this.handleDialogBlur = event => {
      if (event.keyCode === keycode.codes.tab && event.shiftKey && this.props.shouldFocusContentOnTriggerBlur) {
        return;
      }

      this.hide(event);
    };

    this.handleTriggerKeyDown = event => {
      if (!this.props.shouldFocusContentOnTriggerBlur) {
        return;
      }

      if (event.keyCode === keycode.codes.tab && !event.shiftKey) {
        event.preventDefault();

        this._raf.push(requestAnimationFrame(() => {
          this._dialog && this._dialog.focus();
        }));
      }
    };

    this.handleTriggerKeyUp = event => {
      if (event.keyCode === keycode.codes.esc && this.shown && this.isTooltip) {
        // if popover is tooltip, it is managing its own focus region so we need
        // to prevent esc keyup event from reaching FocusRegionManager
        event.preventDefault();
        this.hide(event);
      }
    };

    this.handleTriggerBlur = event => {
      const on = this.props.on;

      if (on && on.indexOf('focus') > -1) {
        this._raf.push(requestAnimationFrame(() => {
          if (!containsActiveElement(this._view)) {
            this.hide(event);
          }
        }));
      }
    };

    this.handlePositioned = position => {
      var _this$props$onPositio, _this$props3;

      const placement = position.placement;
      this.setState({
        placement,
        ...this.computeOffsets(placement)
      });
      (_this$props$onPositio = (_this$props3 = this.props).onPositioned) === null || _this$props$onPositio === void 0 ? void 0 : _this$props$onPositio.call(_this$props3, position);
    };

    this.handlePositionChanged = position => {
      var _this$props$onPositio2, _this$props4;

      const placement = position.placement;
      this.setState({
        placement,
        ...this.computeOffsets(placement)
      });
      (_this$props$onPositio2 = (_this$props4 = this.props).onPositionChanged) === null || _this$props$onPositio2 === void 0 ? void 0 : _this$props$onPositio2.call(_this$props4, position);
    };

    this.state = {
      placement: props.placement,
      offsetX: props.offsetX,
      offsetY: props.offsetY,
      isShowingContent: typeof props.isShowingContent === 'undefined' ? props.defaultIsShowingContent : void 0
    };
    this._id = this.props.id || props.deterministicId();
    this._raf = [];
    this._handleMouseOver = handleMouseOverOut.bind(null, event => {
      this.show(event);
      clearTimeout(this.mouseOutTimeout);
    });
    this._handleMouseOut = handleMouseOverOut.bind(null, event => {
      // this is needed bc the trigger mouseOut fires before tooltip mouseOver
      this.mouseOutTimeout = setTimeout(() => {
        this.hide(event);
      }, 1);
    });
  }

  get isTooltip() {
    return this.props.shouldRenderOffscreen && !this.props.shouldReturnFocus && !this.props.shouldContainFocus && !this.props.shouldFocusContentOnTriggerBlur;
  }

  componentDidMount() {
    if (this.isTooltip) {
      // if popover is being used as a tooltip with no focusable content
      // manage its FocusRegion internally rather than registering it with
      // the FocusRegionManager via Dialog
      this._focusRegion = new FocusRegion(this._contentElement, {
        shouldCloseOnEscape: false,
        shouldCloseOnDocumentClick: true,
        onDismiss: this.hide
      });

      if (this.shown) {
        this._focusRegion.activate();
      }
    }
  }

  componentWillUnmount() {
    this._raf.forEach(request => request.cancel());

    this._raf = [];

    if (this._focusRegion) {
      this._focusRegion.deactivate();

      this._focusRegion.blur();
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
  }

  componentDidUpdate(prevProps, prevState) {
    if (this._focusRegion && this.isTooltip) {
      // if focus region exists, popover is acting as a tooltip
      // so we manually activate and deactivate the region when showing/hiding
      if (!prevProps.isShowingContent && this.props.isShowingContent || !prevState.isShowingContent && this.state.isShowingContent) {
        // changed from hiding to showing
        this._focusRegion.activate();

        this._focusRegion.focus();
      }

      if (prevProps.isShowingContent && !this.props.isShowingContent || prevState.isShowingContent && !this.state.isShowingContent) {
        // changed from showing to hiding
        this._focusRegion.deactivate();
      }
    } // since `offsetX`, `offsetY` and `placement` are saved into the state
    // in the constructor and used from the state later,
    // we need to update the state if these props change


    if (this.props.offsetX !== prevProps.offsetX || this.props.offsetY !== prevProps.offsetY || this.props.placement !== prevProps.placement || this.props.shouldAlignArrow !== prevProps.shouldAlignArrow || this.props.withArrow !== prevProps.withArrow) {
      this.setState({ ...this.computeOffsets(this.placement)
      });
    }
  }

  computeOffsets(placement) {
    let _this$props5 = this.props,
        offsetX = _this$props5.offsetX,
        offsetY = _this$props5.offsetY;

    if (this.props.shouldAlignArrow && this._view) {
      const secondaryPlacement = parsePlacement(placement)[1]; // arrowSize and arrowBorderWidth are component theme variables
      // declared in ContextView's styles.js

      const _ref2 = this._view.props.styles,
            _ref2$arrowSize = _ref2.arrowSize,
            arrowSize = _ref2$arrowSize === void 0 ? 0 : _ref2$arrowSize,
            _ref2$arrowBorderWidt = _ref2.arrowBorderWidth,
            arrowBorderWidth = _ref2$arrowBorderWidt === void 0 ? 0 : _ref2$arrowBorderWidt;
      const offsetAmount = (px(arrowSize) + px(arrowBorderWidth)) * 2;

      if (secondaryPlacement === 'start') {
        offsetX = offsetAmount;
      } else if (secondaryPlacement === 'end') {
        offsetX = -offsetAmount;
      } else if (secondaryPlacement === 'top') {
        offsetY = offsetAmount;
      } else if (secondaryPlacement === 'bottom') {
        offsetY = -offsetAmount;
      }
    }

    return {
      offsetX,
      offsetY
    };
  }

  get placement() {
    let placement = this.props.placement;
    const dir = this.props.dir;
    const isRtl = dir === textDirectionContextConsumer.DIRECTION.rtl;

    if (isRtl) {
      placement = mirrorHorizontalPlacement(placement, ' ');
    }

    return !this.shown && this.props.shouldRenderOffscreen ? 'offscreen' : placement;
  }

  get positionProps() {
    return {
      offsetX: this.state.offsetX,
      offsetY: this.state.offsetY,
      shouldTrackPosition: this.props.shouldTrackPosition && this.shown,
      insertAt: this.props.insertAt,
      placement: this.placement,
      constrain: this.props.constrain,
      onPositioned: this.handlePositioned,
      onPositionChanged: this.handlePositionChanged,
      target: this.props.positionTarget,
      mountNode: this.props.mountNode,
      id: this._id
    };
  }

  get shown() {
    return typeof this.props.isShowingContent === 'undefined' ? this.state.isShowingContent : this.props.isShowingContent;
  }

  get defaultFocusElement() {
    return this.props.defaultFocusElement;
  }

  renderTrigger() {
    let trigger = callRenderProp(this.props.renderTrigger);

    if (trigger) {
      const _this$props6 = this.props,
            on = _this$props6.on,
            shouldContainFocus = _this$props6.shouldContainFocus;
      let onClick = void 0;
      let onFocus = void 0;
      let onMouseOut = void 0;
      let onMouseOver = void 0;
      let expanded;

      if (on && on.indexOf('click') > -1) {
        onClick = event => {
          this.toggle(event);
        };
      }

      if (on && on.indexOf('hover') > -1) {
        error(!(on === 'hover'), '[Popover] Specifying only the `"hover"` trigger limits the visibility' + ' of the Popover to just mouse users. Consider also including the `"focus"` trigger ' + 'so that touch and keyboard only users can see the Popover content as well.');
        onMouseOver = this._handleMouseOver;
        onMouseOut = this._handleMouseOut;
      }

      if (on && on.indexOf('focus') > -1) {
        onFocus = event => {
          this.show(event);
        };
      }

      if (shouldContainFocus) {
        // only set aria-expanded if popover can contain focus
        expanded = this.shown ? 'true' : 'false';
      } else {
        expanded = void 0;
      }

      trigger = safeCloneElement(trigger, {
        ref: el => {
          this._trigger = el;
        },
        'aria-expanded': expanded,
        'data-popover-trigger': true,
        onKeyDown: createChainedFunction(this.handleTriggerKeyDown, this.props.onKeyDown),
        onKeyUp: createChainedFunction(this.handleTriggerKeyUp, this.props.onKeyUp),
        onClick: createChainedFunction(onClick, this.props.onClick),
        onBlur: createChainedFunction(this.handleTriggerBlur, this.props.onBlur),
        onFocus: createChainedFunction(onFocus, this.props.onFocus),
        onMouseOut: createChainedFunction(onMouseOut, this.props.onMouseOut),
        onMouseOver: createChainedFunction(onMouseOver, this.props.onMouseOver)
      });
    }

    return trigger;
  }

  renderContent() {
    let content = callRenderProp(this.props.children);

    if (this.shown && !this.isTooltip) {
      // if popover is NOT being used as a tooltip, create a Dialog
      // to manage the content FocusRegion, when showing
      content = /*#__PURE__*/React.createElement(Dialog, {
        open: this.shown,
        label: this.props.screenReaderLabel,
        ref: el => this._dialog = el,
        display: "block",
        onBlur: this.handleDialogBlur,
        onDismiss: this.handleDialogDismiss,
        liveRegion: this.props.liveRegion,
        defaultFocusElement: this.props.defaultFocusElement,
        shouldContainFocus: this.props.shouldContainFocus,
        shouldReturnFocus: this.props.shouldReturnFocus,
        shouldFocusOnOpen: !this.props.shouldFocusContentOnTriggerBlur,
        shouldCloseOnDocumentClick: this.props.shouldCloseOnDocumentClick,
        shouldCloseOnEscape: this.props.shouldCloseOnEscape
      }, content);
    }

    if (this.shown || this.props.shouldRenderOffscreen) {
      const color = this.props.color;
      let viewProps = {
        // TODO: try to type `ref` better, LegacyRef<T> was not compatible
        ref: c => this._view = c,
        elementRef: el => {
          var _this$props$contentRe, _this$props7;

          this._contentElement = el;
          (_this$props$contentRe = (_this$props7 = this.props).contentRef) === null || _this$props$contentRe === void 0 ? void 0 : _this$props$contentRe.call(_this$props7, el);
        },
        background: color,
        stacking: this.props.stacking,
        shadow: this.props.shadow,
        display: 'block'
      };

      if (this.isTooltip) {
        viewProps = { ...viewProps,
          // Because of a11y reasons popovers should not be hidden when hovered over
          onMouseOver: this._handleMouseOver,
          onMouseOut: this._handleMouseOut
        };
      }

      const placement = this.state.placement;

      if (this.props.withArrow) {
        viewProps = { ...viewProps,
          // TODO: remove background override after contextview is updated
          background: color === 'primary' ? 'default' : 'inverse',
          placement: this.props.dir === textDirectionContextConsumer.DIRECTION.rtl ? mirrorHorizontalPlacement(placement, ' ') : placement
        };
        return /*#__PURE__*/React.createElement(ContextView, viewProps, content);
      } else {
        viewProps = { ...viewProps,
          borderWidth: 'small',
          borderRadius: 'medium',
          ...(color === 'primary-inverse' && {
            borderColor: 'transparent'
          })
        };
        return /*#__PURE__*/React.createElement(View, viewProps, content);
      }
    } else {
      return null;
    }
  }

  render() {
    const positionProps = this.positionProps;

    if (this.props.positionTarget) {
      return /*#__PURE__*/React.createElement("span", {
        ref: this.handleRef
      }, this.renderTrigger(), /*#__PURE__*/React.createElement(Position, positionProps, this.renderContent()));
    } else {
      return /*#__PURE__*/React.createElement(Position, Object.assign({}, positionProps, {
        renderTarget: this.renderTrigger(),
        elementRef: this.handleRef
      }), this.renderContent());
    }
  }

}, _class2.displayName = "Popover", _class2.componentId = 'Popover', _class2.allowedProps = allowedProps, _class2.propTypes = propTypes, _class2.defaultProps = {
  defaultIsShowingContent: false,
  placement: 'bottom center',
  stacking: 'topmost',
  shadow: 'resting',
  offsetX: 0,
  offsetY: 0,
  color: 'primary',
  on: ['hover', 'focus'],
  withArrow: true,
  constrain: 'window',
  insertAt: 'bottom',
  shouldAlignArrow: false,
  shouldTrackPosition: true,
  shouldRenderOffscreen: false,
  shouldContainFocus: false,
  shouldReturnFocus: true,
  shouldCloseOnDocumentClick: true,
  shouldFocusContentOnTriggerBlur: false,
  shouldCloseOnEscape: true
}, _class2)) || _class) || _class) || _class);
export default Popover;
export { Popover };