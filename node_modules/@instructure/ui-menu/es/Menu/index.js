var _dec, _dec2, _dec3, _class, _class2;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/** @jsx jsx */
import React, { Children, Component } from 'react';
import keycode from 'keycode';
import { Popover } from '@instructure/ui-popover';
import { safeCloneElement, matchComponentTypes, withDeterministicId } from '@instructure/ui-react-utils';
import { logError as error } from '@instructure/console';
import { containsActiveElement } from '@instructure/ui-dom-utils';
import { testable } from '@instructure/ui-testable';
import { MenuContext } from '../MenuContext';
import { MenuItem } from './MenuItem';
import { MenuItemGroup } from './MenuItemGroup';
import { MenuItemSeparator } from './MenuItemSeparator';
import { withStyle, jsx } from '@instructure/emotion';
import generateStyle from './styles';
import generateComponentTheme from './theme';
import { propTypes, allowedProps } from './props';

/**
---
category: components
---
@tsProps
**/
let Menu = (_dec = withDeterministicId(), _dec2 = withStyle(generateStyle, generateComponentTheme), _dec3 = testable(), _dec(_class = _dec2(_class = _dec3(_class = (_class2 = class Menu extends Component {
  constructor(props) {
    super(props);
    this.state = {
      hasFocus: false
    };
    this._rootNode = null;
    this._menuItems = [];
    this._popover = null;
    this._trigger = null;
    this._menu = null;
    this._labelId = this.props.deterministicId('Menu__label');
    this._activeSubMenu = void 0;
    this._id = void 0;
    this.ref = null;

    this.handleRef = el => {
      const menuRef = this.props.menuRef;
      this._menu = el;

      if (typeof menuRef === 'function') {
        menuRef(el);
      } // If there is no trigger `<ul>` is the ref, otherwise the trigger


      if (!this.props.trigger) {
        this.ref = el;
      }
    };

    this.registerMenuItem = item => {
      this._menuItems.push(item);
    };

    this.removeMenuItem = item => {
      const index = this.getMenuItemIndex(item);
      error(index >= 0, '[Menu] Could not find registered menu item.');

      if (index >= 0) {
        this._menuItems.splice(index, 1);
      }
    };

    this.getMenuItemIndex = item => {
      return this._menuItems.findIndex(i => i === item);
    };

    this.handleTriggerKeyDown = event => {
      if (this.props.type === 'flyout' && event.keyCode === keycode.codes.right) {
        event.persist();
        this.show(event);
      }
    };

    this.handleTriggerMouseOver = event => {
      if (this.props.type === 'flyout') {
        this.show(event);
      }
    };

    this.handleToggle = shown => {
      if (typeof this.props.onToggle === 'function') {
        this.props.onToggle(shown, this);
      }
    };

    this.handleMenuKeyDown = event => {
      const key = event && event.keyCode;
      const _keycode$codes = keycode.codes,
            down = _keycode$codes.down,
            up = _keycode$codes.up,
            tab = _keycode$codes.tab,
            left = _keycode$codes.left;
      const pgdn = keycode.codes['page down'];
      const pgup = keycode.codes['page up'];

      if (key === down || key === pgdn) {
        event.preventDefault();
        event.stopPropagation();
        this.moveFocus(1);
        this.hideActiveSubMenu(event);
      } else if (key === up || key === pgup) {
        event.preventDefault();
        event.stopPropagation();
        this.moveFocus(-1);
        this.hideActiveSubMenu(event);
      } else if (key === tab || key === left) {
        event.persist();
        this.hide(event);
      }

      if (typeof this.props.onKeyDown === 'function') {
        this.props.onKeyDown(event);
      }
    };

    this.handleMenuItemSelect = (event, value, selected, item) => {
      if (this.props.shouldHideOnSelect) {
        this.hide(event);
      }

      if (typeof this.props.onSelect === 'function') {
        this.props.onSelect(event, value, selected, item);
      }
    };

    this.handleMenuItemFocus = () => {
      this.setState({
        hasFocus: true
      });
    };

    this.handleMenuItemBlur = () => {
      this.setState({
        hasFocus: this.focusedIndex >= 0
      });
    };

    this.handleMenuItemMouseOver = (event, menuItem) => {
      if (this._activeSubMenu && menuItem !== this._activeSubMenu._trigger) {
        this.hideActiveSubMenu(event);
      }
    };

    this.hideActiveSubMenu = event => {
      if (this._activeSubMenu) {
        this._activeSubMenu.hide(event);

        this._activeSubMenu = null;
      }
    };

    this.handleSubMenuToggle = (shown, subMenu) => {
      if (shown) {
        this._activeSubMenu = subMenu;
      }
    };

    this.handleSubMenuDismiss = (event, documentClick) => {
      if (event && event.keyCode === keycode.codes.tab || documentClick) {
        this.hide(event);
      }
    };

    this.hide = event => {
      if (this._popover) {
        this._popover.hide(event);
      }
    };

    this.show = event => {
      if (this._popover) {
        this._popover.show(event);
      }
    };

    this._id = this.props.id || props.deterministicId();
  }

  componentDidMount() {
    var _this$props$makeStyle, _this$props;

    (_this$props$makeStyle = (_this$props = this.props).makeStyles) === null || _this$props$makeStyle === void 0 ? void 0 : _this$props$makeStyle.call(_this$props);
  }

  componentDidUpdate() {
    var _this$props$makeStyle2, _this$props2;

    (_this$props$makeStyle2 = (_this$props2 = this.props).makeStyles) === null || _this$props$makeStyle2 === void 0 ? void 0 : _this$props$makeStyle2.call(_this$props2);
  }

  get menuItems() {
    return this._menuItems;
  }

  focus() {
    if (this.shown) {
      var _this$_menu;

      error(!!((_this$_menu = this._menu) !== null && _this$_menu !== void 0 && _this$_menu.focus), '[Menu] Could not focus the menu.');

      this._menu.focus();
    } else {
      var _this$_trigger;

      error(!!((_this$_trigger = this._trigger) !== null && _this$_trigger !== void 0 && _this$_trigger.focus), '[Menu] Could not focus the trigger.');

      this._trigger.focus();
    }
  }

  focused() {
    if (this.shown) {
      return containsActiveElement(this._menu) || this.state.hasFocus;
    } else {
      return containsActiveElement(this._trigger);
    }
  }

  get focusedIndex() {
    return this.menuItems.findIndex(item => {
      return item && item.focused === true;
    });
  }

  moveFocus(step) {
    const count = this.menuItems ? this.menuItems.length : 0;

    if (count <= 0) {
      return;
    }

    const current = this.focusedIndex < 0 && step < 0 ? 0 : this.focusedIndex;
    const nextItem = this.menuItems[(current + count + step) % count];
    error(typeof nextItem !== 'undefined' && typeof nextItem.focus !== 'undefined', '[Menu] Could not focus next menu item.');
    nextItem.focus();
  }

  get shown() {
    return this._popover ? this._popover.shown : true;
  }

  renderChildren() {
    const _this$props3 = this.props,
          children = _this$props3.children,
          disabled = _this$props3.disabled;
    let count = 0;
    return Children.map(children, child => {
      if (!matchComponentTypes(child, ['MenuItemSeparator', 'MenuItem', 'MenuItemGroup', 'Menu'])) {
        return;
      }

      count += 1;
      const isTabbable = !this.state.hasFocus && count === 1;

      if (matchComponentTypes(child, ['MenuItemSeparator'])) {
        return jsx("li", {
          role: "none"
        }, child);
      }

      const menuItemChild = child;
      const controls = menuItemChild.props['aria-controls'] || menuItemChild.props.controls || this.props['aria-controls'] || this.props.controls;

      if (matchComponentTypes(child, ['MenuItem'])) {
        return jsx("li", {
          role: "none"
        }, safeCloneElement(child, {
          controls,
          children: child.props.children,
          disabled: disabled || child.props.disabled,
          onFocus: this.handleMenuItemFocus,
          onBlur: this.handleMenuItemBlur,
          onSelect: this.handleMenuItemSelect,
          onMouseOver: this.handleMenuItemMouseOver,
          tabIndex: isTabbable ? 0 : -1
        }));
      }

      if (matchComponentTypes(child, ['MenuItemGroup'])) {
        return jsx("li", {
          role: "none"
        }, safeCloneElement(child, {
          label: child.props.label,
          controls,
          disabled: disabled || child.props.disabled,
          onFocus: this.handleMenuItemFocus,
          onBlur: this.handleMenuItemBlur,
          onSelect: this.handleMenuItemSelect,
          onMouseOver: this.handleMenuItemMouseOver,
          isTabbable
        }));
      }

      if (matchComponentTypes(child, ['Menu'])) {
        const submenuDisabled = disabled || child.props.disabled;
        return jsx("li", {
          role: "none"
        }, safeCloneElement(child, {
          type: 'flyout',
          controls,
          disabled: submenuDisabled,
          onSelect: this.handleMenuItemSelect,
          placement: 'end top',
          offsetX: -5,
          offsetY: 5,
          withArrow: false,
          onToggle: this.handleSubMenuToggle,
          onDismiss: this.handleSubMenuDismiss,
          trigger: jsx(MenuItem, {
            onMouseOver: this.handleMenuItemMouseOver,
            onFocus: this.handleMenuItemFocus,
            onBlur: this.handleMenuItemBlur,
            tabIndex: isTabbable ? 0 : -1,
            type: "flyout",
            disabled: submenuDisabled
          }, child.props.title || child.props.label)
        }));
      }

      return;
    });
  }

  renderMenu() {
    var _this$props$styles;

    const _this$props4 = this.props,
          disabled = _this$props4.disabled,
          label = _this$props4.label,
          trigger = _this$props4.trigger,
          onKeyUp = _this$props4.onKeyUp;
    const labelledBy = this.props['aria-labelledby'];
    const controls = this.props['aria-controls'];
    return jsx(MenuContext.Provider, {
      value: {
        removeMenuItem: this.removeMenuItem,
        registerMenuItem: this.registerMenuItem
      }
    }, jsx("ul", {
      role: "menu",
      "aria-label": label,
      tabIndex: 0,
      css: (_this$props$styles = this.props.styles) === null || _this$props$styles === void 0 ? void 0 : _this$props$styles.menu,
      "aria-labelledby": labelledBy || (trigger ? this._labelId : void 0),
      "aria-controls": controls,
      "aria-disabled": disabled ? 'true' : void 0,
      onKeyDown: this.handleMenuKeyDown,
      onKeyUp: onKeyUp,
      ref: this.handleRef
    }, this.renderChildren()));
  }

  render() {
    const _this$props5 = this.props,
          show = _this$props5.show,
          defaultShow = _this$props5.defaultShow,
          placement = _this$props5.placement,
          withArrow = _this$props5.withArrow,
          trigger = _this$props5.trigger,
          mountNode = _this$props5.mountNode,
          popoverRef = _this$props5.popoverRef,
          disabled = _this$props5.disabled,
          onDismiss = _this$props5.onDismiss,
          onFocus = _this$props5.onFocus,
          onMouseOver = _this$props5.onMouseOver,
          offsetX = _this$props5.offsetX,
          offsetY = _this$props5.offsetY;
    return trigger ? jsx(Popover, {
      isShowingContent: show,
      defaultIsShowingContent: defaultShow,
      onHideContent: (event, _ref) => {
        let documentClick = _ref.documentClick;

        if (typeof onDismiss === 'function') {
          onDismiss(event, documentClick);
        }

        this.handleToggle(false);
      },
      onShowContent: () => this.handleToggle(true),
      mountNode: mountNode,
      placement: placement,
      withArrow: withArrow,
      id: this._id,
      on: ['click'],
      shouldContainFocus: true,
      shouldReturnFocus: true,
      onFocus: onFocus,
      onMouseOver: onMouseOver,
      offsetX: offsetX,
      offsetY: offsetY,
      elementRef: element => {
        this.ref = element;
      },
      ref: el => {
        this._popover = el;

        if (typeof popoverRef === 'function') {
          popoverRef(el);
        }
      },
      renderTrigger: safeCloneElement(trigger, {
        ref: el => {
          this._trigger = el;
        },
        'aria-haspopup': true,
        id: this._labelId,
        onMouseOver: this.handleTriggerMouseOver,
        onKeyDown: this.handleTriggerKeyDown,
        disabled: trigger.props.disabled || disabled
      })
    }, this.renderMenu()) : this.renderMenu();
  }

}, _class2.displayName = "Menu", _class2.componentId = 'Menu', _class2.propTypes = propTypes, _class2.allowedProps = allowedProps, _class2.defaultProps = {
  label: null,
  disabled: false,
  trigger: null,
  placement: 'bottom center',
  defaultShow: false,
  mountNode: null,
  constrain: 'window',
  shouldHideOnSelect: true,
  shouldFocusTriggerOnClose: true,
  withArrow: true,
  offsetX: 0,
  offsetY: 0
}, _class2.Item = MenuItem, _class2.Group = MenuItemGroup, _class2.Separator = MenuItemSeparator, _class2.contextType = MenuContext, _class2)) || _class) || _class) || _class);
export default Menu;
export { Menu, MenuItem, MenuItemGroup, MenuItemSeparator };