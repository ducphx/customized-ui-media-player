import React from 'react';
import type { PropValidators, MenuTheme, OtherHTMLAttributes } from '@instructure/shared-types';
import type { WithStyleProps, ComponentStyle } from '@instructure/emotion';
import type { PlacementPropValues, PositionConstraint, PositionMountNode } from '@instructure/ui-position';
import type { Popover } from '@instructure/ui-popover';
import type { WithDeterministicIdProps } from '@instructure/ui-react-utils';
import { MenuItem } from './MenuItem';
import type { Menu } from './index';
import type { MenuItemProps } from './MenuItem/props';
declare type MenuOwnProps = {
    /**
     * Children of type `Menu.Item`, `Menu.Group`, `Menu.Separator`, or `Menu`
     */
    children?: React.ReactNode;
    /**
     * Description of the `<Menu />`. The component uses it to add its value to
     * the `aria-label` attribute.
     */
    label?: string;
    /**
     * Is the `<Menu />` disabled
     */
    disabled?: boolean;
    /**
     * The trigger element, if the `<Menu />` is to render as a popover
     */
    trigger?: React.ReactNode;
    /**
     * If a trigger is supplied, where should the `<Menu />` be placed (relative to the trigger)
     */
    placement?: PlacementPropValues;
    /**
     * Should the `<Menu />` be open for the initial render
     */
    defaultShow?: boolean;
    /**
     * Is the `<Menu />` open (should be accompanied by `onToggle`)
     */
    show?: boolean;
    /**
     * Callback fired when the `<Menu />` is toggled open/closed. When used with `show`,
     * the component will not control its own state.
     */
    onToggle?: (show: boolean, menu: Menu) => void;
    /**
     * Callback fired when an item within the `<Menu />` is selected
     */
    onSelect?: (e: React.MouseEvent, value: MenuItemProps['value'] | MenuItemProps['value'][], selected: MenuItemProps['selected'], args: MenuItem) => void;
    /**
     * If a trigger is supplied, callback fired when the `<Menu />` is closed
     */
    onDismiss?: (event: React.UIEvent | React.FocusEvent, documentClick: boolean) => void;
    /**
     * If a trigger is supplied, callback fired when the `<Menu />` trigger is focused
     */
    onFocus?: (event: React.FocusEvent) => void;
    /**
     * If a trigger is supplied, callback fired onMouseOver for the `<Menu />` trigger
     */
    onMouseOver?: (event: React.MouseEvent) => void;
    /**
     * Callback fired on the onKeyDown of the `<Menu />`
     */
    onKeyDown?: (event: React.KeyboardEvent<HTMLUListElement>) => void;
    /**
     * Callback fired on the onKeyUp of the `<Menu />`
     */
    onKeyUp?: (event: React.KeyboardEvent<HTMLUListElement>) => void;
    /**
     * A function that returns a reference to the `<Menu />`
     */
    menuRef?: (el: HTMLUListElement | null) => void;
    /**
     * A function that returns a reference to the `<Popover />`
     */
    popoverRef?: (el: Popover | null) => void;
    /**
     * If a trigger is supplied, an element or a function returning an element to use as the mount node
     * for the `<Menu />` (defaults to `document.body`)
     */
    mountNode?: PositionMountNode;
    /**
     * The parent in which to constrain the menu.
     * One of: 'window', 'scroll-parent', 'parent', 'none', an element,
     * or a function returning an element
     */
    constrain?: PositionConstraint;
    /**
     * If a trigger is supplied, should the `<Menu />` hide when an item is selected
     */
    shouldHideOnSelect?: boolean;
    /**
     * If a trigger is supplied, should the `<Menu />` focus the trigger on after closing
     */
    shouldFocusTriggerOnClose?: boolean;
    /**
     * The type of `<Menu />`
     */
    type?: 'flyout';
    id?: string;
    /**
     * Whether or not an arrow pointing to the trigger should be rendered
     */
    withArrow?: boolean;
    /**
     * The horizontal offset for the positioned content.
     * Works only if `trigger` is provided.
     */
    offsetX?: string | number;
    /**
     * The vertical offset for the positioned content.
     * Works only if `trigger` is provided.
     */
    offsetY?: string | number;
};
declare type PropKeys = keyof MenuOwnProps;
declare type AllowedPropKeys = Readonly<Array<PropKeys>>;
declare type MenuProps = MenuOwnProps & WithStyleProps<MenuTheme, MenuStyle> & Omit<OtherHTMLAttributes<MenuOwnProps>, 'controls'> & {
    controls?: React.AriaAttributes['aria-controls'];
} & WithDeterministicIdProps;
declare type MenuStyle = ComponentStyle<'menu'>;
declare const propTypes: PropValidators<PropKeys>;
declare const allowedProps: AllowedPropKeys;
export type { MenuProps, MenuStyle };
export { propTypes, allowedProps };
//# sourceMappingURL=props.d.ts.map