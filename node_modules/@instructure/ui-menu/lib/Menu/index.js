"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Menu = void 0;
Object.defineProperty(exports, "MenuItem", {
  enumerable: true,
  get: function () {
    return _MenuItem.MenuItem;
  }
});
Object.defineProperty(exports, "MenuItemGroup", {
  enumerable: true,
  get: function () {
    return _MenuItemGroup.MenuItemGroup;
  }
});
Object.defineProperty(exports, "MenuItemSeparator", {
  enumerable: true,
  get: function () {
    return _MenuItemSeparator.MenuItemSeparator;
  }
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _keycode = _interopRequireDefault(require("keycode"));

var _Popover = require("@instructure/ui-popover/lib/Popover");

var _safeCloneElement = require("@instructure/ui-react-utils/lib/safeCloneElement.js");

var _matchComponentTypes = require("@instructure/ui-react-utils/lib/matchComponentTypes.js");

var _withDeterministicId = require("@instructure/ui-react-utils/lib/DeterministicIdContext/withDeterministicId.js");

var _console = require("@instructure/console");

var _containsActiveElement = require("@instructure/ui-dom-utils/lib/containsActiveElement.js");

var _testable = require("@instructure/ui-testable/lib/testable.js");

var _MenuContext = require("../MenuContext");

var _MenuItem = require("./MenuItem");

var _MenuItemGroup = require("./MenuItemGroup");

var _MenuItemSeparator = require("./MenuItemSeparator");

var _emotion = require("@instructure/emotion");

var _styles = _interopRequireDefault(require("./styles"));

var _theme = _interopRequireDefault(require("./theme"));

var _props = require("./props");

var _dec, _dec2, _dec3, _class, _class2;

/**
---
category: components
---
@tsProps
**/
let Menu = (_dec = (0, _withDeterministicId.withDeterministicId)(), _dec2 = (0, _emotion.withStyle)(_styles.default, _theme.default), _dec3 = (0, _testable.testable)(), _dec(_class = _dec2(_class = _dec3(_class = (_class2 = class Menu extends _react.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasFocus: false
    };
    this._rootNode = null;
    this._menuItems = [];
    this._popover = null;
    this._trigger = null;
    this._menu = null;
    this._labelId = this.props.deterministicId('Menu__label');
    this._activeSubMenu = void 0;
    this._id = void 0;
    this.ref = null;

    this.handleRef = el => {
      const menuRef = this.props.menuRef;
      this._menu = el;

      if (typeof menuRef === 'function') {
        menuRef(el);
      } // If there is no trigger `<ul>` is the ref, otherwise the trigger


      if (!this.props.trigger) {
        this.ref = el;
      }
    };

    this.registerMenuItem = item => {
      this._menuItems.push(item);
    };

    this.removeMenuItem = item => {
      const index = this.getMenuItemIndex(item);
      (0, _console.logError)(index >= 0, '[Menu] Could not find registered menu item.');

      if (index >= 0) {
        this._menuItems.splice(index, 1);
      }
    };

    this.getMenuItemIndex = item => {
      return this._menuItems.findIndex(i => i === item);
    };

    this.handleTriggerKeyDown = event => {
      if (this.props.type === 'flyout' && event.keyCode === _keycode.default.codes.right) {
        event.persist();
        this.show(event);
      }
    };

    this.handleTriggerMouseOver = event => {
      if (this.props.type === 'flyout') {
        this.show(event);
      }
    };

    this.handleToggle = shown => {
      if (typeof this.props.onToggle === 'function') {
        this.props.onToggle(shown, this);
      }
    };

    this.handleMenuKeyDown = event => {
      const key = event && event.keyCode;
      const _keycode$codes = _keycode.default.codes,
            down = _keycode$codes.down,
            up = _keycode$codes.up,
            tab = _keycode$codes.tab,
            left = _keycode$codes.left;
      const pgdn = _keycode.default.codes['page down'];
      const pgup = _keycode.default.codes['page up'];

      if (key === down || key === pgdn) {
        event.preventDefault();
        event.stopPropagation();
        this.moveFocus(1);
        this.hideActiveSubMenu(event);
      } else if (key === up || key === pgup) {
        event.preventDefault();
        event.stopPropagation();
        this.moveFocus(-1);
        this.hideActiveSubMenu(event);
      } else if (key === tab || key === left) {
        event.persist();
        this.hide(event);
      }

      if (typeof this.props.onKeyDown === 'function') {
        this.props.onKeyDown(event);
      }
    };

    this.handleMenuItemSelect = (event, value, selected, item) => {
      if (this.props.shouldHideOnSelect) {
        this.hide(event);
      }

      if (typeof this.props.onSelect === 'function') {
        this.props.onSelect(event, value, selected, item);
      }
    };

    this.handleMenuItemFocus = () => {
      this.setState({
        hasFocus: true
      });
    };

    this.handleMenuItemBlur = () => {
      this.setState({
        hasFocus: this.focusedIndex >= 0
      });
    };

    this.handleMenuItemMouseOver = (event, menuItem) => {
      if (this._activeSubMenu && menuItem !== this._activeSubMenu._trigger) {
        this.hideActiveSubMenu(event);
      }
    };

    this.hideActiveSubMenu = event => {
      if (this._activeSubMenu) {
        this._activeSubMenu.hide(event);

        this._activeSubMenu = null;
      }
    };

    this.handleSubMenuToggle = (shown, subMenu) => {
      if (shown) {
        this._activeSubMenu = subMenu;
      }
    };

    this.handleSubMenuDismiss = (event, documentClick) => {
      if (event && event.keyCode === _keycode.default.codes.tab || documentClick) {
        this.hide(event);
      }
    };

    this.hide = event => {
      if (this._popover) {
        this._popover.hide(event);
      }
    };

    this.show = event => {
      if (this._popover) {
        this._popover.show(event);
      }
    };

    this._id = this.props.id || props.deterministicId();
  }

  componentDidMount() {
    var _this$props$makeStyle, _this$props;

    (_this$props$makeStyle = (_this$props = this.props).makeStyles) === null || _this$props$makeStyle === void 0 ? void 0 : _this$props$makeStyle.call(_this$props);
  }

  componentDidUpdate() {
    var _this$props$makeStyle2, _this$props2;

    (_this$props$makeStyle2 = (_this$props2 = this.props).makeStyles) === null || _this$props$makeStyle2 === void 0 ? void 0 : _this$props$makeStyle2.call(_this$props2);
  }

  get menuItems() {
    return this._menuItems;
  }

  focus() {
    if (this.shown) {
      var _this$_menu;

      (0, _console.logError)(!!((_this$_menu = this._menu) !== null && _this$_menu !== void 0 && _this$_menu.focus), '[Menu] Could not focus the menu.');

      this._menu.focus();
    } else {
      var _this$_trigger;

      (0, _console.logError)(!!((_this$_trigger = this._trigger) !== null && _this$_trigger !== void 0 && _this$_trigger.focus), '[Menu] Could not focus the trigger.');

      this._trigger.focus();
    }
  }

  focused() {
    if (this.shown) {
      return (0, _containsActiveElement.containsActiveElement)(this._menu) || this.state.hasFocus;
    } else {
      return (0, _containsActiveElement.containsActiveElement)(this._trigger);
    }
  }

  get focusedIndex() {
    return this.menuItems.findIndex(item => {
      return item && item.focused === true;
    });
  }

  moveFocus(step) {
    const count = this.menuItems ? this.menuItems.length : 0;

    if (count <= 0) {
      return;
    }

    const current = this.focusedIndex < 0 && step < 0 ? 0 : this.focusedIndex;
    const nextItem = this.menuItems[(current + count + step) % count];
    (0, _console.logError)(typeof nextItem !== 'undefined' && typeof nextItem.focus !== 'undefined', '[Menu] Could not focus next menu item.');
    nextItem.focus();
  }

  get shown() {
    return this._popover ? this._popover.shown : true;
  }

  renderChildren() {
    const _this$props3 = this.props,
          children = _this$props3.children,
          disabled = _this$props3.disabled;
    let count = 0;
    return _react.Children.map(children, child => {
      if (!(0, _matchComponentTypes.matchComponentTypes)(child, ['MenuItemSeparator', 'MenuItem', 'MenuItemGroup', 'Menu'])) {
        return;
      }

      count += 1;
      const isTabbable = !this.state.hasFocus && count === 1;

      if ((0, _matchComponentTypes.matchComponentTypes)(child, ['MenuItemSeparator'])) {
        return (0, _emotion.jsx)("li", {
          role: "none"
        }, child);
      }

      const menuItemChild = child;
      const controls = menuItemChild.props['aria-controls'] || menuItemChild.props.controls || this.props['aria-controls'] || this.props.controls;

      if ((0, _matchComponentTypes.matchComponentTypes)(child, ['MenuItem'])) {
        return (0, _emotion.jsx)("li", {
          role: "none"
        }, (0, _safeCloneElement.safeCloneElement)(child, {
          controls,
          children: child.props.children,
          disabled: disabled || child.props.disabled,
          onFocus: this.handleMenuItemFocus,
          onBlur: this.handleMenuItemBlur,
          onSelect: this.handleMenuItemSelect,
          onMouseOver: this.handleMenuItemMouseOver,
          tabIndex: isTabbable ? 0 : -1
        }));
      }

      if ((0, _matchComponentTypes.matchComponentTypes)(child, ['MenuItemGroup'])) {
        return (0, _emotion.jsx)("li", {
          role: "none"
        }, (0, _safeCloneElement.safeCloneElement)(child, {
          label: child.props.label,
          controls,
          disabled: disabled || child.props.disabled,
          onFocus: this.handleMenuItemFocus,
          onBlur: this.handleMenuItemBlur,
          onSelect: this.handleMenuItemSelect,
          onMouseOver: this.handleMenuItemMouseOver,
          isTabbable
        }));
      }

      if ((0, _matchComponentTypes.matchComponentTypes)(child, ['Menu'])) {
        const submenuDisabled = disabled || child.props.disabled;
        return (0, _emotion.jsx)("li", {
          role: "none"
        }, (0, _safeCloneElement.safeCloneElement)(child, {
          type: 'flyout',
          controls,
          disabled: submenuDisabled,
          onSelect: this.handleMenuItemSelect,
          placement: 'end top',
          offsetX: -5,
          offsetY: 5,
          withArrow: false,
          onToggle: this.handleSubMenuToggle,
          onDismiss: this.handleSubMenuDismiss,
          trigger: (0, _emotion.jsx)(_MenuItem.MenuItem, {
            onMouseOver: this.handleMenuItemMouseOver,
            onFocus: this.handleMenuItemFocus,
            onBlur: this.handleMenuItemBlur,
            tabIndex: isTabbable ? 0 : -1,
            type: "flyout",
            disabled: submenuDisabled
          }, child.props.title || child.props.label)
        }));
      }

      return;
    });
  }

  renderMenu() {
    var _this$props$styles;

    const _this$props4 = this.props,
          disabled = _this$props4.disabled,
          label = _this$props4.label,
          trigger = _this$props4.trigger,
          onKeyUp = _this$props4.onKeyUp;
    const labelledBy = this.props['aria-labelledby'];
    const controls = this.props['aria-controls'];
    return (0, _emotion.jsx)(_MenuContext.MenuContext.Provider, {
      value: {
        removeMenuItem: this.removeMenuItem,
        registerMenuItem: this.registerMenuItem
      }
    }, (0, _emotion.jsx)("ul", {
      role: "menu",
      "aria-label": label,
      tabIndex: 0,
      css: (_this$props$styles = this.props.styles) === null || _this$props$styles === void 0 ? void 0 : _this$props$styles.menu,
      "aria-labelledby": labelledBy || (trigger ? this._labelId : void 0),
      "aria-controls": controls,
      "aria-disabled": disabled ? 'true' : void 0,
      onKeyDown: this.handleMenuKeyDown,
      onKeyUp: onKeyUp,
      ref: this.handleRef
    }, this.renderChildren()));
  }

  render() {
    const _this$props5 = this.props,
          show = _this$props5.show,
          defaultShow = _this$props5.defaultShow,
          placement = _this$props5.placement,
          withArrow = _this$props5.withArrow,
          trigger = _this$props5.trigger,
          mountNode = _this$props5.mountNode,
          popoverRef = _this$props5.popoverRef,
          disabled = _this$props5.disabled,
          onDismiss = _this$props5.onDismiss,
          onFocus = _this$props5.onFocus,
          onMouseOver = _this$props5.onMouseOver,
          offsetX = _this$props5.offsetX,
          offsetY = _this$props5.offsetY;
    return trigger ? (0, _emotion.jsx)(_Popover.Popover, {
      isShowingContent: show,
      defaultIsShowingContent: defaultShow,
      onHideContent: (event, _ref) => {
        let documentClick = _ref.documentClick;

        if (typeof onDismiss === 'function') {
          onDismiss(event, documentClick);
        }

        this.handleToggle(false);
      },
      onShowContent: () => this.handleToggle(true),
      mountNode: mountNode,
      placement: placement,
      withArrow: withArrow,
      id: this._id,
      on: ['click'],
      shouldContainFocus: true,
      shouldReturnFocus: true,
      onFocus: onFocus,
      onMouseOver: onMouseOver,
      offsetX: offsetX,
      offsetY: offsetY,
      elementRef: element => {
        this.ref = element;
      },
      ref: el => {
        this._popover = el;

        if (typeof popoverRef === 'function') {
          popoverRef(el);
        }
      },
      renderTrigger: (0, _safeCloneElement.safeCloneElement)(trigger, {
        ref: el => {
          this._trigger = el;
        },
        'aria-haspopup': true,
        id: this._labelId,
        onMouseOver: this.handleTriggerMouseOver,
        onKeyDown: this.handleTriggerKeyDown,
        disabled: trigger.props.disabled || disabled
      })
    }, this.renderMenu()) : this.renderMenu();
  }

}, _class2.displayName = "Menu", _class2.componentId = 'Menu', _class2.propTypes = _props.propTypes, _class2.allowedProps = _props.allowedProps, _class2.defaultProps = {
  label: null,
  disabled: false,
  trigger: null,
  placement: 'bottom center',
  defaultShow: false,
  mountNode: null,
  constrain: 'window',
  shouldHideOnSelect: true,
  shouldFocusTriggerOnClose: true,
  withArrow: true,
  offsetX: 0,
  offsetY: 0
}, _class2.Item = _MenuItem.MenuItem, _class2.Group = _MenuItemGroup.MenuItemGroup, _class2.Separator = _MenuItemSeparator.MenuItemSeparator, _class2.contextType = _MenuContext.MenuContext, _class2)) || _class) || _class) || _class);
exports.Menu = Menu;
var _default = Menu;
exports.default = _default;