var _dec, _dec2, _dec3, _class, _class2;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/** @jsx jsx */
import React, { Component } from 'react';
import { debounce } from '@instructure/debounce';
import { canUseDOM, getBoundingClientRect } from '@instructure/ui-dom-utils';
import { safeCloneElement, ensureSingleChild, hack } from '@instructure/ui-react-utils';
import { logError as error } from '@instructure/console';
import { testable } from '@instructure/ui-testable';
import { withStyle, jsx } from '@instructure/emotion';
import generateStyle from './styles';
import generateComponentTheme from './theme';
import truncate from './utils/truncate';
import { propTypes, allowedProps } from './props';

/**
---
category: components
---
@tsProps
**/
let TruncateText = (_dec = withStyle(generateStyle, generateComponentTheme), _dec2 = testable(), _dec3 = hack(['shouldTruncateWhenInvisible']), _dec(_class = _dec2(_class = _dec3(_class = (_class2 = class TruncateText extends Component {
  constructor(props) {
    super(props);
    this.ref = null;
    this._text = void 0;
    this._debounced = void 0;
    this._stage = null;
    this._wasTruncated = void 0;
    this._resizeListener = void 0;

    this.update = () => {
      if (this.ref) {
        this.setState(this.initialState);
      }
    };

    this.state = this.initialState;
  }

  get _ref() {
    return this.ref;
  }

  get initialState() {
    return {
      isTruncated: false,
      needsSecondRender: true,
      truncatedElement: void 0,
      truncatedText: void 0
    };
  }

  componentDidMount() {
    const _this$props = this.props,
          children = _this$props.children,
          makeStyles = _this$props.makeStyles;
    makeStyles === null || makeStyles === void 0 ? void 0 : makeStyles();

    if (children) {
      this.checkChildren();
      const txt = ensureSingleChild(children);
      this._text = txt ? txt : void 0;
      this.truncate();
      this._debounced = debounce(this.update, this.props.debounce, {
        leading: true,
        trailing: true
      });

      const _getBoundingClientRec = getBoundingClientRect(this.ref),
            origWidth = _getBoundingClientRec.width;

      this._resizeListener = new ResizeObserver(entries => {
        // requestAnimationFrame call is needed becuase some truncatetext test cases
        // failed due to ResizeObserver was not able to deliver all observations within a single animation frame
        // see: https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded
        requestAnimationFrame(() => {
          for (const entry of entries) {
            const width = entry.contentRect.width;

            if (origWidth !== width) {
              this.props.debounce === 0 ? this.update() : this._debounced();
            }
          }
        });
      });

      this._resizeListener.observe(this.ref);
    }
  }

  componentWillUnmount() {
    if (this._resizeListener) {
      this._resizeListener.disconnect();
    }

    if (this._debounced) {
      this._debounced.cancel();
    }
  }

  componentDidUpdate(prevProps) {
    const _this$props2 = this.props,
          children = _this$props2.children,
          onUpdate = _this$props2.onUpdate,
          makeStyles = _this$props2.makeStyles;
    makeStyles === null || makeStyles === void 0 ? void 0 : makeStyles();
    const _this$state = this.state,
          isTruncated = _this$state.isTruncated,
          needsSecondRender = _this$state.needsSecondRender,
          truncatedText = _this$state.truncatedText;

    if (children) {
      if (prevProps !== this.props) {
        if (prevProps.children !== this.props.children) {
          // reset internal text variable if children change
          this.checkChildren();
          const txt = ensureSingleChild(children);
          this._text = txt ? txt : void 0;
        } // require the double render whenever props change


        this.setState(this.initialState);
        return;
      }

      if (!needsSecondRender && (isTruncated || this._wasTruncated)) {
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(isTruncated, truncatedText);
        this._wasTruncated = isTruncated;
      } else {
        this.truncate();
      }
    }
  }

  checkChildren() {
    error(!(() => {
      let isTooDeep = false;
      const text = ensureSingleChild(this.props.children);
      React.Children.forEach(text.props.children, child => {
        if (child.props) {
          React.Children.forEach(child.props.children, grandChild => {
            // currently we don't support node trees deeper than 2 levels
            // truncation will still occur on their text content, but their actual node structure will be lost
            if (grandChild.props) {
              isTooDeep = true;
            }
          });
        }
      });
      return isTooDeep;
    })(), `[TruncateText] Some children are too deep in the node tree and will not render.`);
  }

  truncate() {
    if (!this.state.needsSecondRender) {
      return;
    }

    if (canUseDOM) {
      var _this$props$styles;

      const result = truncate(this._stage, { ...this.props,
        parent: this.ref ? this.ref : void 0,
        lineHeight: (_this$props$styles = this.props.styles) === null || _this$props$styles === void 0 ? void 0 : _this$props$styles.lineHeight
      });

      if (result) {
        const element = this.renderChildren(result.isTruncated, result.data, result.constraints.width);
        this.setState({
          needsSecondRender: false,
          isTruncated: result.isTruncated,
          truncatedElement: element,
          truncatedText: result.text
        });
      }
    } else {
      var _this$ref, _this$ref2;

      const textContent = (_this$ref = this.ref) !== null && _this$ref !== void 0 && _this$ref.textContent ? (_this$ref2 = this.ref) === null || _this$ref2 === void 0 ? void 0 : _this$ref2.textContent : void 0; // if dom isn't available, use original children

      this.setState({
        needsSecondRender: false,
        isTruncated: false,
        truncatedElement: this._text,
        truncatedText: textContent
      });
    }
  }

  renderChildren(truncated, data, width) {
    var _this$props$styles2;

    if (!truncated) {
      return this._text;
    }

    const childElements = []; // iterate over each node used in the truncated string

    for (let i = 0; i < data.length; i++) {
      const item = data[i];
      const element = this._text.props.children[i];
      const nodeText = item.join('');

      if (element && element.props) {
        // if node is an html element and not just a string
        childElements.push(safeCloneElement(element, element.props, nodeText));
      } else {
        childElements.push(nodeText);
      }
    } // this spacer element is set to the max width the full text could
    // potentially be without this, text in `width: auto` elements won't expand
    // to accommodate more text, once truncated


    childElements.push(jsx("span", {
      css: (_this$props$styles2 = this.props.styles) === null || _this$props$styles2 === void 0 ? void 0 : _this$props$styles2.spacer,
      style: {
        width: width || void 0
      }
    }));
    const children = React.Children.map(childElements, child => child);
    return this._text.props ? safeCloneElement(this._text, this._text.props, children) : children;
  }

  render() {
    var _this$props$styles3;

    const truncatedElement = this.state.truncatedElement;
    const children = this.props.children;
    return jsx("span", {
      css: (_this$props$styles3 = this.props.styles) === null || _this$props$styles3 === void 0 ? void 0 : _this$props$styles3.truncateText,
      ref: el => {
        this.ref = el;
      }
    }, children && (truncatedElement ? null : jsx("span", {
      ref: el => {
        this._stage = el;
      }
    }, ensureSingleChild(children))), truncatedElement);
  }

}, _class2.displayName = "TruncateText", _class2.componentId = 'TruncateText', _class2.allowedProps = allowedProps, _class2.propTypes = propTypes, _class2.defaultProps = {
  maxLines: 1,
  ellipsis: '\u2026',
  truncate: 'character',
  position: 'end',
  ignore: [' ', '.', ','],
  debounce: 0
}, _class2)) || _class) || _class) || _class);
export default TruncateText;
export { TruncateText };