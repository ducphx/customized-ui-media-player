"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TruncateText = void 0;

var _react = _interopRequireWildcard(require("react"));

var _debounce = require("@instructure/debounce");

var _canUseDOM = require("@instructure/ui-dom-utils/lib/canUseDOM.js");

var _getBoundingClientRect = require("@instructure/ui-dom-utils/lib/getBoundingClientRect.js");

var _safeCloneElement = require("@instructure/ui-react-utils/lib/safeCloneElement.js");

var _ensureSingleChild = require("@instructure/ui-react-utils/lib/ensureSingleChild.js");

var _hack = require("@instructure/ui-react-utils/lib/hack.js");

var _console = require("@instructure/console");

var _testable = require("@instructure/ui-testable/lib/testable.js");

var _emotion = require("@instructure/emotion");

var _styles = _interopRequireDefault(require("./styles"));

var _theme = _interopRequireDefault(require("./theme"));

var _truncate = _interopRequireDefault(require("./utils/truncate"));

var _props = require("./props");

var _dec, _dec2, _dec3, _class, _class2;

/**
---
category: components
---
@tsProps
**/
let TruncateText = (_dec = (0, _emotion.withStyle)(_styles.default, _theme.default), _dec2 = (0, _testable.testable)(), _dec3 = (0, _hack.hack)(['shouldTruncateWhenInvisible']), _dec(_class = _dec2(_class = _dec3(_class = (_class2 = class TruncateText extends _react.Component {
  constructor(props) {
    super(props);
    this.ref = null;
    this._text = void 0;
    this._debounced = void 0;
    this._stage = null;
    this._wasTruncated = void 0;
    this._resizeListener = void 0;

    this.update = () => {
      if (this.ref) {
        this.setState(this.initialState);
      }
    };

    this.state = this.initialState;
  }

  get _ref() {
    return this.ref;
  }

  get initialState() {
    return {
      isTruncated: false,
      needsSecondRender: true,
      truncatedElement: void 0,
      truncatedText: void 0
    };
  }

  componentDidMount() {
    const _this$props = this.props,
          children = _this$props.children,
          makeStyles = _this$props.makeStyles;
    makeStyles === null || makeStyles === void 0 ? void 0 : makeStyles();

    if (children) {
      this.checkChildren();
      const txt = (0, _ensureSingleChild.ensureSingleChild)(children);
      this._text = txt ? txt : void 0;
      this.truncate();
      this._debounced = (0, _debounce.debounce)(this.update, this.props.debounce, {
        leading: true,
        trailing: true
      });

      const _getBoundingClientRec = (0, _getBoundingClientRect.getBoundingClientRect)(this.ref),
            origWidth = _getBoundingClientRec.width;

      this._resizeListener = new ResizeObserver(entries => {
        // requestAnimationFrame call is needed becuase some truncatetext test cases
        // failed due to ResizeObserver was not able to deliver all observations within a single animation frame
        // see: https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded
        requestAnimationFrame(() => {
          for (const entry of entries) {
            const width = entry.contentRect.width;

            if (origWidth !== width) {
              this.props.debounce === 0 ? this.update() : this._debounced();
            }
          }
        });
      });

      this._resizeListener.observe(this.ref);
    }
  }

  componentWillUnmount() {
    if (this._resizeListener) {
      this._resizeListener.disconnect();
    }

    if (this._debounced) {
      this._debounced.cancel();
    }
  }

  componentDidUpdate(prevProps) {
    const _this$props2 = this.props,
          children = _this$props2.children,
          onUpdate = _this$props2.onUpdate,
          makeStyles = _this$props2.makeStyles;
    makeStyles === null || makeStyles === void 0 ? void 0 : makeStyles();
    const _this$state = this.state,
          isTruncated = _this$state.isTruncated,
          needsSecondRender = _this$state.needsSecondRender,
          truncatedText = _this$state.truncatedText;

    if (children) {
      if (prevProps !== this.props) {
        if (prevProps.children !== this.props.children) {
          // reset internal text variable if children change
          this.checkChildren();
          const txt = (0, _ensureSingleChild.ensureSingleChild)(children);
          this._text = txt ? txt : void 0;
        } // require the double render whenever props change


        this.setState(this.initialState);
        return;
      }

      if (!needsSecondRender && (isTruncated || this._wasTruncated)) {
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(isTruncated, truncatedText);
        this._wasTruncated = isTruncated;
      } else {
        this.truncate();
      }
    }
  }

  checkChildren() {
    (0, _console.logError)(!(() => {
      let isTooDeep = false;
      const text = (0, _ensureSingleChild.ensureSingleChild)(this.props.children);

      _react.default.Children.forEach(text.props.children, child => {
        if (child.props) {
          _react.default.Children.forEach(child.props.children, grandChild => {
            // currently we don't support node trees deeper than 2 levels
            // truncation will still occur on their text content, but their actual node structure will be lost
            if (grandChild.props) {
              isTooDeep = true;
            }
          });
        }
      });

      return isTooDeep;
    })(), `[TruncateText] Some children are too deep in the node tree and will not render.`);
  }

  truncate() {
    if (!this.state.needsSecondRender) {
      return;
    }

    if (_canUseDOM.canUseDOM) {
      var _this$props$styles;

      const result = (0, _truncate.default)(this._stage, { ...this.props,
        parent: this.ref ? this.ref : void 0,
        lineHeight: (_this$props$styles = this.props.styles) === null || _this$props$styles === void 0 ? void 0 : _this$props$styles.lineHeight
      });

      if (result) {
        const element = this.renderChildren(result.isTruncated, result.data, result.constraints.width);
        this.setState({
          needsSecondRender: false,
          isTruncated: result.isTruncated,
          truncatedElement: element,
          truncatedText: result.text
        });
      }
    } else {
      var _this$ref, _this$ref2;

      const textContent = (_this$ref = this.ref) !== null && _this$ref !== void 0 && _this$ref.textContent ? (_this$ref2 = this.ref) === null || _this$ref2 === void 0 ? void 0 : _this$ref2.textContent : void 0; // if dom isn't available, use original children

      this.setState({
        needsSecondRender: false,
        isTruncated: false,
        truncatedElement: this._text,
        truncatedText: textContent
      });
    }
  }

  renderChildren(truncated, data, width) {
    var _this$props$styles2;

    if (!truncated) {
      return this._text;
    }

    const childElements = []; // iterate over each node used in the truncated string

    for (let i = 0; i < data.length; i++) {
      const item = data[i];
      const element = this._text.props.children[i];
      const nodeText = item.join('');

      if (element && element.props) {
        // if node is an html element and not just a string
        childElements.push((0, _safeCloneElement.safeCloneElement)(element, element.props, nodeText));
      } else {
        childElements.push(nodeText);
      }
    } // this spacer element is set to the max width the full text could
    // potentially be without this, text in `width: auto` elements won't expand
    // to accommodate more text, once truncated


    childElements.push((0, _emotion.jsx)("span", {
      css: (_this$props$styles2 = this.props.styles) === null || _this$props$styles2 === void 0 ? void 0 : _this$props$styles2.spacer,
      style: {
        width: width || void 0
      }
    }));

    const children = _react.default.Children.map(childElements, child => child);

    return this._text.props ? (0, _safeCloneElement.safeCloneElement)(this._text, this._text.props, children) : children;
  }

  render() {
    var _this$props$styles3;

    const truncatedElement = this.state.truncatedElement;
    const children = this.props.children;
    return (0, _emotion.jsx)("span", {
      css: (_this$props$styles3 = this.props.styles) === null || _this$props$styles3 === void 0 ? void 0 : _this$props$styles3.truncateText,
      ref: el => {
        this.ref = el;
      }
    }, children && (truncatedElement ? null : (0, _emotion.jsx)("span", {
      ref: el => {
        this._stage = el;
      }
    }, (0, _ensureSingleChild.ensureSingleChild)(children))), truncatedElement);
  }

}, _class2.displayName = "TruncateText", _class2.componentId = 'TruncateText', _class2.allowedProps = _props.allowedProps, _class2.propTypes = _props.propTypes, _class2.defaultProps = {
  maxLines: 1,
  ellipsis: '\u2026',
  truncate: 'character',
  position: 'end',
  ignore: [' ', '.', ','],
  debounce: 0
}, _class2)) || _class) || _class) || _class);
exports.TruncateText = TruncateText;
var _default = TruncateText;
exports.default = _default;